#include <iostream>
#include <vector>
using namespace std;
struct queue {
	int inf;
	queue* next; //структура очень похожа на стек, даже содержащиеся поля идентичны
};
void push(queue*& h, queue*& t, int x) {// функция вставки элемента в начало очереди
	//уже можно заметить, что функция похожа на такую у стека, отличается она только тем, что нужно проверку, если очередь пустая
	queue* r = new queue;
	r->inf = x;
	r->next = nullptr;
	if (!h && !t) {//собсна сама проверка, нужно проверить, если оба указателя смотрят в пустоту, то по сути просто изначальную очередь представляем как ту, которую создали для решения
		h = t = r;
	}
	else {//иначе идём также как и со стеком, но в обратную сторону
		t->next = r;
		t = r;
	}
}
int pop(queue*& h, queue*& t) {//функция удаления первого элемента из очереди, почти полностью идентична таковой из стеков
	queue* r = h;
	int i = h->inf;
	h = h->next;
	if (!h) t = nullptr;//единственное отличие - это необходимость проверить, если мы вдруг удалили единственный элемент в очереди, то нужно обнулить и второй указатель 
	delete r;
	return i;
}
int main() {
	queue* h= nullptr;
	queue* t = nullptr;//создаём очередь 
	int n, m, x,k,y,w;
	bool fl=true;
	vector <vector<int>> Gr;//создаём двумерный вектор, выступающий в роли списка смежности
	cout << "Put a number of nodes" << endl;
	cin >> n;//спрашиваем число вершин
	for (int i = 0; i < n; i++) {
		Gr.push_back(vector<int>());
		cout << "Put number of neighbor nodes of node " << i<<" ";
		cin >> k;
		cout << i<<"Neighbor nodes: ";
		for (int j = 0; j < k; j++) {
			cin >> w;
			Gr[i].push_back(w);//заполняем список смежности
		}
	}
	int* a = new int[n];
	for (int i = 0; i < n; i++) a[i] = 0;//создаём массив а, регистрирующий посещение вершин
	cout << "Where we would start? ";
	cin >> x;//спрашиваем, откуда начинаем обход
	a[x] = 1;//регистрируем посещение начальной вершины
	push(h, t, x);//и добавляем сам узел в очередь
	cout << x;
	while (h && fl) {
		x=pop(h, t);//достанем из очереди первый элемент
		for (int i = 0; i < Gr[x].size(); i++) {//также пройдём по остальным вершинам, смежным с тем, который мы достали из очереди 
			if (a[Gr[x][i]] == 0) {
				y = Gr[x][i];
				a[y] = 1;
				push(h, t, y);
				cout << y<<" ";//тут операции, аналогичные тем, что мы выполняли для первого элемента
			}
		}
		fl = false;
		for (int k = 0; k < n; k++) {
			if (a[k] == 0) {
				fl = true;//при каждом завершении просмотра элементов, смежных с текущим будем проверять, если мы посетили уже все вершины, если да, то заканчиваем работу
				break;
			}
		}
	}
}