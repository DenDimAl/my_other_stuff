#include<iostream>
using namespace std;
/*создадим структуру стеков, суть их такова, что каждый стек как бы содержит только один элемент,
он просто ссылается на другой стек с другим элементом, такая самоссылка происходит до тех пор,
пока указатель не упрётся в пустоту*/
struct stack {
	char inf;//сам элемент
	stack* next;//стек поменьше
};
//для решения задачи будем заталкивать в стек нужное слово, а затем выведем, стерев сам стек
//далее об этом подробнее
void push(stack*& h, char x) {//функция добавления нового элемента в стек
	stack* r = new stack;//раз стек, очевидно, после добавления станет больше, то нам нужен будет уже новый стек
	r->inf = x;//элементу нового стека мы присваиваем значение добавляемого элемента
	r->next = h;//а новый стек пусть будет ссылаться на исходный
	h = r;//и меняем местами кто на кого ссылается
}
char pop(stack*& h) {//функция удаления элемента из стека, возвращающая удаляемый элемент 
	char i = h->inf;//для сохранения элемента запишем его в новую переменную
	stack* p = h;//для удаления нам нужно будет удалить сам стек, содержащий удаляемый элемент 
	h = h->next;//но, чтобы не потерять весь основной стек нам нужно переназначить ссылку предыщего стека с текущего на следующую 
	delete p;//собсна удаляем стек
	return i;//возвращаем удаллёный элемент
}
void reverse(stack*& h) {//функция переворачивания стека
	stack* h1 = nullptr;
	while (h) push(h1, pop(h));//тут всё просто просто создадим новый стек и в силу его особенностей просто запихаем в него элементы нужного стека, они сами запишутся в нужном порядке
	h = h1;//а затем изначальному стеку просто присвоим значение перевёрнутого 
}
int prior(char h) {//функция получения приоритета операции
	if (h == '-' || h == '+') return 1;
	if (h == '*' || h == '/') return 2;
	return 0;
} 
int main() {
	//Идея алгоритма заключается в том, что можно получить префиксную запись выражения, если
	//записать постфиксную запись выражения записанного наоборот, а после ещё раз перевернуть эту постфиксную запись
	string expression,rexpression;//создадим две строки - одна исходная, другая - это исходная задом наоборот
	cout << "Put mathematical expression" << endl;
	cin >> expression;
	stack* a=nullptr;
	reverse(expression.begin(), expression.end());//собсна переворачивем строку
	for (int i = 0; i < expression.size(); i++) {
		if (expression[i] == '(') expression[i] = ')';
		else if (expression[i] == ')') expression[i] = '(';//и заменяем все скобки, так, чтобы они были записаны в нужном порядке
	}
	expression = '(' + expression + ')';//дополнительно добавим скобки по концам выражения
	string res;
	for (int i = 0; i < expression.size(); i++) {
		if (isdigit(expression[i])) res.push_back(expression[i]);
		else if (expression[i] == '(') push(a, expression[i]);
		//сначала будем выписывать в стэк цифры и открывающие скобки, т. к. скобки нужны будут для определения приоритета операций
		//числа, ну потому что их порядок напрямую мы изменять никак не будем
		else if (!a && !isdigit(expression[i]) && expression[i] != ')') push(a, expression[i]);
		//затем начианаем потихоньку записывать операции, вот тут следим за руками
		else if (expression[i] == ')') {
			while (a->inf != '(') res.push_back(pop(a));
			pop(a);
		//сначала, если мы напоролись в выражении на закрывающую скобку, то последовательно выписаем в результат все цифры и операции, т. к. из-за нахождения в скобках у них будет приоритет выше
		}
		else if (prior(expression[i]) > prior(a->inf)) push(a, expression[i]); 
		else {
			while (prior(expression[i]) <= prior(a->inf)) {
				res.push_back(pop(a));
			}
			push(a, expression[i]);//затем, выйдя их скобок, мы будем записывать вперёд операции с высшим приоритетом
		}
	}
	while (a) {
		res.push_back(pop(a));//и, наконец, записываем всё то, что осталось в стеке в связи с наименьшим приоритетом
	}
	cout <<"Prefix form is"<< endl;
	
	reverse(res.begin(), res.end());//выводим ответ
	cout << res;
}